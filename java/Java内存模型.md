# Java内存模型
- Java栈：本地变量表(存储着局部变量，有原始类型和对象类型（引用）），返回地址。每一个线程都有自己的一个JVM栈。每一个栈中又存在若干个栈帧，每一个方法调用产生一个栈帧，栈帧包括2部分，1是局部变量，2是操作数（方法执行过程中产生的中间结果)
- Java堆：new出来的对象本身（对象的引用，如果是局部变量存在Java栈，或者是静态变量则在方法区)
- 方法区：代码的信息（如类的信息，方法，字段），方法区主要存放类与类之间关系的数据，而这部分数据被加载到内存之后，基本上是不会发生变更的，
- 程序计数器：当前线程所执行的字节码的行号指示器。每一个线程都有一个自己的私有程序计数器。
- 本地栈：Native栈，即非Java代码执行时的栈
- GC Root：在Java栈中存储的局部变量，全局变量/常量，静态变量等
- -Xmx:最大堆内存，Xms：最小堆内存，注意：不包括永久代。-Xss：栈空间的大小Stack Space（跟StackOverFlow有关系),-XX:PermSize永久代的大小 -XX:MaxPermSize，最大永久代的大小（永久其实就是方法区,常量也在永久带,注意Java8HotSpot已经不支持永久代的设置了，因为已经永久代已经移动到了native memory)
 
  > Compatibility Guide for JDK 8 says that in Java 8 the command line flag MaxPermSize has been   removed. The reason is that the permanent generation was removed from the hotspot heap and was moved to native memory. 

- 内存模型。分成年轻代（eden，from，to），年老代。为什么这么分？因为根据实践显示，大部分对象在生产之后，很快就消亡了，那么就得根据不同的对象采用不同的垃圾回收算法。
- GC。STEP1.eden满：eden->S0。STEP2：eden满：eden&S0->S1。这样的结果是S1和eden空。重复STEP1，STEP2。直到S0或者S1满，那么移动到年老代。
- 吞吐量与响应时间。吞吐量：单位时间内处理完(从发起请求到完成请求)事务的数量。响应时间：从发起请求到完成请求的时间。这两个数值都是指平均值。举例说明。单个银行窗口处理能力（系统的处理能力）是1个人/1小时，在只有1个窗口的情况下，如果同时有8个人排队，响应时间是4.5小时（8个人全部处理完的时间(1+2+3+4+5+6+7+8)/8=36/8=4.5，这个是从客户角度的计算),吞吐量为8/4.5。而如果增加到2个窗口（即增加系统处理能力），响应时间变成了2.25小时(8个人全部处理完的时间(1+2+3+4)x2/8=20/8=2.5)，吞吐量为8/2.5。当窗口增加到4个时，响应时间变成1.5小时(8个人全部处理完的时间(1+2)x4/8=12/8=1.5)，吞吐量为8/1.5。当然，银行的处理能力（窗口数）是一定的，即不可能无限增加，那么随着办理业务的人数的增加，如同时有20人办理业务，那么响应时间为3小时（8个人全部处理完的时间/8=60/20=3），而吞吐量是20/3人=6.7/小时。可以看出吞吐量和响应时间都变大了。


